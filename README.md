# Fundamentos arquitetura de software
projeto para fins de estudo sobre o ecossitema de arquitetura de software.


## Pilares fundamentais da OOP
- Estado
- Comportamento
- Abstra√ß√£o
- Heran√ßa
- Polimorfismo
- Encapsulamento: Esconder m√©todos privados da classe para expor outro que fa√ßa uso dele. Chamar m√©todos sem saber como ele funciona internamente.

*"Na orienta√ß√£o a objetos devemos sempre buscar o baixo acoplamento e a alta coes√£o entre os objetos."* <br>
**Acoplamento:** Uma depend√™ncia direta entre um objeto e outro. Quando um objeto muda o outro muda por consequ√™ncia.<br>
**Coes√£o:** Objetos executando uma √∫nica responsabilidade livre de uma depend√™ncia direta com um outro objeto.

## Modificadores de acesso 
 - Public: N√£o possui acesso restrito.
 - Protected: Apenas a classe que est√° herdando aquela classe pode acessar aquele m√©todo.
 - Internal: Acesso limitado ao assemblie para classes e m√©todos.
 - Private: Acesso limitado ao assemblie em caso de CLASSE. Limitado a classe em caso de M√âTODO.
 - Private protected: Acesso limitados ao mesmo assemblie E Acesso limitado a classes que est√£o derivando dela *somente para m√©todos*
 - Protected internal: Acesso limitado a classes que est√£o derivando dela OU Acesso limitados ao mesmo assemblie. *somente para m√©todos*

 - Sealed: Classe selada nunca pode ser herdada. Somente inst√¢nciada.

## Classe Abstrata Vs Interface
- Interface:
    - Contrato simples, onde se voc√™ est√° querendo usar essa interface voc√™ precisa implementar todos os m√©todos dela.
    - Obriga a quem herdar realizar a implementa√ß√£o dos seus m√©todos expostos.

- Classe abstrata:
    - Al√©m de obrigar a implementar os m√©todos abstratos a classe abstrata tamb√©m possui comportamentos que podem ser derivados.

## Interface Vs Implementa√ß√£o
- **Interface:** Diminui o acoplamento devida a baixa depend√™ncia e aumenta a coes√£o. Onde a classe passa a depender da abstra√ß√£o e n√£o mais da implementa√ß√£o.

- **Implementa√ß√£o:** Utilizar classes concretas no meio de um c√≥digo que faz outras coisas. Onde gera um relacionalmento direto da classe que est√° implementando para a classe que est√° sendo implementa, esse √© um caso de alto acoplamento.

*"Sempre prefira depender de abstra√ß√µes(interface) inv√©s de implementa√ß√µes. A classe que precisa instanciar suas depend√™ncias, ela mesmo se resolver, n√£o passar a responsabilidade para quem ta querendo usa-la."* 

## Heran√ßa Vs Composi√ß√£o
*√â interessante realizar uma avalia√ß√£o se a classe abtra√≠da √â A classe especializada ou seja, se a classe especializada utiliza todos os comportamentos da sua abstra√ß√£o, somente ai deve ser feito uma Heran√ßa no mais opte por uma composi√ß√£o.*

- **Heran√ßa:** Alto acoplamento e herda exp√µe todos os comportamentos da classe abstra√≠da.
- **Composi√ß√£o:** S√≥ utiliza o necess√°rio na classe que est√° sendo composta, baixo acoplamento.

## Princ√≠pios S.O.L.I.D
- **SRP:** Single responsability principle.
    * Uma classe deve ter apenas um/e um motivo para ser modificada.
- **OCP:** Open/Closed principle
    * Entidades de software (classe, m√≥dulos, fun√ß√µes, etc) devem estar abertas para *extens√£o* mas fechadas para *modifica√ß√µes*.
- **LSP:** Liskov substitution principle
    * Se q(x) √© uma propriedade demonstr√°vel dos objetos X de tipo T. Ent√£o q(x) deve ser verdadeiro para objetos Y de tipo S onde S √© um subtipo de T. *subclasses devem ser substituidas por suas superClasses*
- **ISP:** Interface segregation principle
    * Clientes n√£o devem ser for√ßados a depender de m√©todos que n√£o usam. *muitas interfaces espec√≠ficas s√£o melhores que uma interface √∫nica*
- **DIP:** Dependency inversion principle
    * M√≥dulos de alto n√≠vel, n√£o devem depender de m√≥dulos de baixo n√≠vel. Ambos devem depender de abstra√ß√£o. Abstra√ß√µes n√£o devem depender de detalhes. Detalhes devem depender de abstra√ß√µes. *dependa de uma abstra√ß√£o e n√£o de uma implementa√ß√£o*

*Os princ√≠pios SOLID devem ser aplicados para se obter os benef√≠cios da orienta√ß√£o a objeto.*

## Inje√ß√£o de depend√™ncia (DI)

- Entendendo container DI
    * ioc benchmack: <a href="https://www.palmmedia.de/blog/2011/8/30/ioc-container-benchmark-performance-comparison" target="_blank">üëÄbenchmarks-ioc-dotnet</a>
- Ciclo de vida:
    * Scoped: Criado apenas uma vez por cliente-request.
    * Transiente: A inst√¢ncia  da classe ser√° criada toda vez que for injetada em alguma classe.
    * Singleton: A inst√¢ncia  do objeto √© criada e permanece durante todo tempo de execu√ß√£o da aplica√ß√£o.
- Generics
- Service Locator
- Multiplas implementa√ß√µes

## Clean code
- Linhas de c√≥digo
- N√∫meros de m√©todos
- N√∫mero de classes
- Linha de c√≥digo por m√©todo
- Complexidade ciclom√°tica: ifs aninhado
- N√∫mero de estruturas de decis√£o
- Escolha os nomes que revelem inten√ß√£o
- Por que existe
- O que faz
- Como √© usado
- Use nomes f√°ceis de se encontrar
- Use nomes pronunci√°veis
- Evite siglas ou acr√¥nimos
- N√£o economize palavras
- Revele a inten√ß√£o do c√≥digo
- Evite palavras que podem ser vari√°veis ou palavras reservadas em outras plataformas
- O tipo n√£o precisa estar no nome
- Evite trocadilhos, n√£o misture idioma, n√£o mescle nomes.


## Boas pr√°ticas
- Nome de classe devem ser SUBSTANTIVOS
- Nome de m√©todos devem conter VERBOS de
prefer√™ncia no infinitivo.
- N√£o seja gen√©rico
- M√©todos <= 20 linhas
- Linha <= 100 caracteres
- Classe <= 500 linhas
- Extraia trechos em m√©todos privados
- M√©todos devem fazer apenas uma coisa, faz√™-la certa e somente faz√™-la.
- Evite muitos par√¢metros
- N√£o deixe o m√©todo mentir dizendo que faz uma coisa e faz outras "escondidas"
- Se o m√©todo tiver mais de uma responsabilidade extraia em dois ou mais.
- Leia seu m√©todo de cima para baixo como uma narrativa, ele deve fazer sentido.
- Aplique uma boa indenta√ß√£o.

## Coment√°rios
- Coment√°rios n√£o v√£o ajudar um c√≥digo ruim ser melhor interpretado.
- Um c√≥digo que requer coment√°rio, precisa ser reescrito.
- N√£o deixe trechos de c√≥digo comentado

* Quando comentar ?
- Alertar consequ√™ncias que pode vir a causar
- Licen√ßa, direitos autorais, etc.
- Necessidade de explicar uma regra de neg√≥cio interna.
- Decis√µes de design de c√≥digo
- Gerar documenta√ß√£o do c√≥digo

## Tratamento de erros
- Tratar e prever poss√≠veis exce√ß√µes √© de responsabilidade do desenvolvedor.
- Retorne exceptions e n√£o c√≥digo de erro.
- Informe o m√°ximo que puder em sua exception.(n√£o para o cliente)
- Se necess√°rio crie exceptions personalizadas para um problema espec√≠fico.
- N√£o retorne NULL

* Regra dos escoteiros:
"Deixe a √°rea de acampamento mais limpa de como voc√™ a encontrou".

## Design Patterns
*S√£o padr√µes de c√≥digo para solu√ß√µes de problemas conhecidos. O objetivo n√£o √© reinventar a roda e sim aplicar uma solu√ß√£o com um  bom design de c√≥digo.*

### O padr√µes est√£o separados por 3 familias, s√£o elas:
- **Criacional:** _Fornecem meios de cria√ß√£o de obj e de como ser√° instanciado._
    * Abstract Factory: F√°brica de f√°brica que delega a cria√ß√£o do produto a uma fabrica concreta.
    * Factory Method
    * Singleton
- **Estrutural:** _Tratam da composi√ß√£o de obj por heran√ßa e interfaces para diferentes funcionalidades._
    * Adapter
    * Facade
    * Composite
- **Comportamental:** _Tratam das intera√ß√µes e comunica√ß√£o entre os objetos al√©m da divis√£o de responsabilidade._
    * Command
    * Strategy
    * Observer
- **Consultar padr√µes dotnet:**
    * <a href="www.dofactory.com/net/design-patterns" target="_blank">üëÄclick-me</a>

## Estilos arquiteturais
*"Um estilo arquitetural √© uma abordagem de como projetar e entregar uma aplica√ß√£o. Trata-se de como organizar os componentes respons√°veis de uma arquitetura, como eles ir√£o interagir entre s√≠ e quais aspectos tecnol√≥gicos ir√£o atender. Os estilos podem coexistir, onde o mesmo projeto pode possuir mais de um estilo."*

- **Arquitetura monol√≠tica**
    * Onde todo o sistema est√° acoplado a um s√≥ projeto, desde o cliente ao servidor.
- **Arquitetura em camadas**
    * Separa√ß√£o de camadas com suas respectivas responsabilidades
- **Arquitetura rest**
    * Estilo cliente, servidor realizando requests.
- **Arquitetura microservices**
    * Granulariza√ß√£o dos servi√ßos em v√°rias partes independentes.
- **Arquitetura SOA**
    * SOA vs Microservices: O estilo √© o mesmo por√©m o micro √© quebrado em servi√ßos menores.
- **Arquitetura de plugins(wordpress)**
- **Arquitetura de Client-Servidor**
- **Arquitetura pipe e filters**

## Padr√µes arquiteturais
*Os padr√µes arquiteturais s√£o semelhantes aos "Design Patterns", mas possuem um escopo diferente. S√£o estrat√©gias de alto n√≠vel que diz respeito a componentes de grande escala as propriedades globais de um sistema. Um projeto de arquitetura pode conter diversos estilos e cada estilo pode utilizar diversos padr√µes. Um padr√£o pode ser um subconjunto de um estilo arquitetural visando um escopo espec√≠fico.*

- **Padr√£o MVC**
     * **Padr√£o: Define uma forma√ß√£o de responsabilidades e como elas conversam entre s√≠** 
- **padr√£o CQRS**
- **Arquiteura 3 camadas**
    * Onde a mesma √© um estilo e um padr√£o
    * **Estilo: Ao dividir as camadas.**
    * **Padr√£o: Porque cada camada possu√≠ uma responsabilidade espec√≠fica.**
- **Arquitetura cebola**
    * Onde a mesma √© um estilo e um padr√£o
    * **Estilo: Separa√ß√£o em camadas.**
    * **Padr√£o: Forma que ela se comporta e a forma que resolve o problema.** 
- **Arquitetura Port&Adapters(Hexagonal)**
    * Onde a mesma √© um estilo e um padr√£o
    * **Estilo: A forma que √© prosposta de como a arquitetura vai trabalhar.**
    * **Padr√£o: √â o catalogo de estilos que ela ir√° acumular para que essa implement√ß√£o seja poss√≠vel.**

## CQRS - Command Query Responsability Segregation
*Um padr√£o arquitetural onde o foco principal √© separar os meios de leitura e escrita de dados. Altera√ß√µes de dados s√£o realizados via **Commands** e leituras de dados que s√£o realizados via **Queries***

- **Commands**
    * Representa uma inten√ß√£o de mudan√ßa no estado de uma entidade. S√£o expressivos e representam uma √∫nica inten√ß√£o de neg√≥cio(Insert, update, delete).
- **Queries**
    * √â a forma de obter dados de um banco ou origem de dados para atender as necessidades da aplica√ß√£o.

*"Podemos considerar que toda aplica√ß√£o que salva em uma base de dados e busque em outra √© um padr√£o CQRS."*
* <a href="https://www.eduardopires.net.br/category/cqrs/" target="_blank">üëÄclick-me</a>

## Event Sourcing
*Uma forma de salvar todos os estados anteriores de uma entidade. Podendo assim colhendo comportamentos dos usu√°rios, at√© mesmo dar replay e retornar a entidade ao seu estado inicial.*

## Domain-Driven Design(DDD)
*√â um guia de como entender um neg√≥cio, organiza-lo em um conjunto de princ√≠pios, criar uma modelagem com base no neg√≥cio e implementar utilizando diversas boas pr√°ticas. Razoavelmente f√°cil de entender, por√©m dif√≠cil de aplicar.*

- **Processo de "implementa√ß√£o" do DDD:**
    * Entender o neg√≥cio
    * Extrair a linguagem ub√≠qua
    * Modelagem estr√°tegica
    * Definir a arquitetura
    * Modelagem t√°tica

## Arquitetura Evolutivas
*Ser cuidadoso, evitar implementa√ß√µes desnecess√°rias, se poss√≠vel adie.*
*"Um bom arquiteto permite que decis√µes importantes sejam adiadas e um bom arquiteto maximiza o n√∫mero de decis√µes tomadas."*
*"Uma arquitetura evolutiva suporta mudan√ßas cont√≠nuas e incrementais como um primeiro princ√≠pio por meio de v√°rios aspectos."*

- Sempre considere a complexidade
    * **Acidental:** A complexidade acidental √© aquela que surge durante o processo de desenvolvimento, ou seja, ela √© **causada** pela abordagem escolhida para resolver o problema.
    * **Essencial:** J√° a essencial √© basicamente a complexidade que nosso "software" se prop√µe resolver. Sim! Infelizmente existem problemas complexos, e √© neles que temos que focar.

## Lei de conway's Law
*"Qualquer empresa que projeta um sistema, inevitavelmente produz um projeto cuja estrutura √© uma c√≥pia da estrutura de comunica√ß√£o da organiza√ß√£o."* **Melvin Conway**

## Agilidade e o manifesto √°gil
<a href="https://agilemanifesto.org" target="_blank">manifesto</a>

## DevOps
*O termo DevOps deriva da jun√ß√£o das palavras **"desenvolvimento"** e **"opera√ß√£o"**, sendo uma pr√°tica de engenharia de software que possui o intuito de unificar o desenvolvimento de software(Dev) e a opera√ß√£o de software(Ops). O mesmo pretende fornecer em ciclos de desenvolvimento menores, frequ√™ncia de implata√ß√£o aumentada, libera√ß√£o mais seguras, em alinhamento pr√≥ximo com os objetivos de neg√≥cio.*

**Planejamento ‚û°Ô∏è build ‚û°Ô∏è CI/CD ‚û°Ô∏è Deploy ‚û°Ô∏è Operate ‚û°Ô∏è Continuous feedbacks ‚ôæÔ∏è**

## Princ√≠pio DRY(Dont Repeat Yourself)
*Cada parte do conhecimento deve ter uma representa√ß√£o √∫nica, n√£o amb√≠gua e e definitiva dentro da aplica√ß√£o.*

## Princ√≠pio KISS (Keep It Simple, Stupid)
*O kiss valorizaa simplicidade do projeto e defende que toda a complexidade desnecess√°ria seja descartada.*

## Princ√≠pio YAGNI (You Ain't Gonna Need It)
*Uma orienta√ß√£o que sugere n√£o adicionar funcionalidades ao c√≥digo fonte de uma aplica√ß√£o at√© que estas sejam realmente necess√°rias.*
